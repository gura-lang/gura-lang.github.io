---
layout: page
lang: en
title: Flow Control
---

# {{ page.title }}

## Conditional Branch

Like other programming languages, Gura also provides conditional branch control
that you've already been familiar with. See the code below:

    if (x < 0) {
        println('x is less than zero')
    } elsif (x > 0) {
        println('x is greater than zero')
    } else {
        println('x is equal to zero')
    }

Although appearance is very similar with that of other languages, there's a big difference.
In Gura, `if` is NOT a statement but a function, which means that `if` has a return value.

Consider the following code:

    str = if (x < 0) {
        'less than zero'
    } elsif (x > 0) {
        'greater than zero'
    } else {
        'equal to zero'
    }

In this case, `if` would have a return
with a value of last-evaluated result of `if`, `elsif` or `else`.

When `if` has no following `else` and its condition is not evaluated as `true`,
it will return `nil`.


## Repeat Control

Here are some simple codes that use typical repeat controls.

Sample code of `for`:

    for (fruit in ['orange', 'apple', 'grape']) {
        println(fruit)
    }

Sample code of `repeat`:


    repeat (5) {
        println('hello world')
    }

Sample code of `while`:

    n = 0
    while (n < 5) {
        println(n)
        n += 1
    }

You can specify a block parameter as following that takes a number of repeating count starting from zero:

    repeat (10) {|i|
        println('hello world ', i)
    }

As these are also implemented as functions, you can see more special features with them.

Appending an attribute `:list` causes the repeating process to generate a list
that contains evaluated result of each loop as its elements.
In the following example, `x` will be a list of `[0, 2, 4, 6, 8]`.

    x = repeat (5):list {|i|
         i * 2
    }

An attribute `:iter` would have a more interesting result. Take a look at the code below:

    x = repeat (5):iter {|i|
         i * 2
    }

In this case, repeating process is not executed when the `repeat` function is evaluated.
`x` is an *iterator* that generates values of 0, 2, 4, 6 and 8,
and these values are only available when the iterator is actually evaluated.

The following code shows how to get the value after evaluating the iterator using Implicit Mapping:

    println(x)

Following code evaluates `x` step by step to confirm that it actually works as an iterator.

    println(x.next())
    println(x.next())
    println(x.next())
    println(x.next())
    println(x.next())

And now, to a next topic about iterators generated by repeating functions.

Consider the following code.

    f() = {
        n = 0
        while (n < 5):iter {
            n += 1
            n
        }
    }
    x = f()

The function `f` returns an iterator created by `while`,
which is expected to generate values of 1, 2, 3, 4 and 5.
In this case, the repeat body has a reference to a variable named `n` that belongs
to the scope of function `f`.
Can an iterator refer to a variable that may be destroyed at the end of a function?

Actually, it's OK. An iterator created by a repeating function owns an environment
in which the function has been called.
In the above example, the variable `n` is owned by the returned iterator.

You'll see more practical usage of this feature in [this](../articles/Script-to-Generate-Prime-Numbers.html).
