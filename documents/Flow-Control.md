---
layout: page
lang: en
title: Flow Control
chapter: 8
---

## {{ page.chapter }}. Flow Control


## {{ page.chapter }}.1. Branch

Branch may be the most common flow-control in a program.
Just like other programming language,
Gura also provides `if` - `elsif` - `else` sequence.
However, they're realized as functions, not as statements.

These elements are implemented by the following functions.

Function `if`:

    if (`cond):leader {block}

Function `elsif`:

    elsif (`cond):leader:trailer {block}

Function `else`:

    else():trailer {block}

They are concatenated with leader-trailer relationship,
which means that a closing curly bracket of the preceding function
must be in the same line as the top of the succceding one.

    if (x) { /* branch 1 */ } elsif (y) { /* branch 2 */ } else { /* branch 3 */ }

Of course, contents in the blocks may be written in multiple lines.
This enables you to write a program in a similar syntax as other languages.

    if (x) {
        
        /* branch 1 */
        
    } elsif (y) {
        
        /* branch 2 */
        
    } else {
        
        /* branch 3 */
        
    }

Function `if` and `elsif` check the evaluated result of the expression `cond`.
If it's determined as `true`, the block procedure will be evaluated,
otherwise, the trailing function will be evaluated.


----

Although appearance is very similar with that of other languages, there's a big difference.
In Gura, `if` is NOT a statement but a function, which means that `if` has a return value.

Consider the following code:

    str = if (x < 0) {
        'less than zero'
    } elsif (x > 0) {
        'greater than zero'
    } else {
        'equal to zero'
    }

In this case, `if` would have a return
with a value of last-evaluated result of `if`, `elsif` or `else`.

When `if` has no following `else` and its condition is not evaluated as `true`,
it will return `nil`.




## {{ page.chapter }}.2. Repeat

## {{ page.chapter }}.2.1. `repeat`

    repeat (n?:number) {block}
    
## {{ page.chapter }}.2.2. `while`

    while (`cond) {block}
    
## {{ page.chapter }}.2.3. `for`

    for (`expr+) {block}

## {{ page.chapter }}.2.4. `cross`

    cross (`expr+) {block}

## {{ page.chapter }}.2.5. Flow Control in Repeat Sequence

    break
    
    continue
    

## {{ page.chapter }}.2.6. List Generation


## {{ page.chapter }}.2.7. Iterator Generation

Appending an attribute `:list` causes the repeating process to generate a list
that contains evaluated result of each loop as its elements.
In the following example, `x` will be a list of `[0, 2, 4, 6, 8]`.

    x = repeat (5):list {|i|
         i * 2
    }

An attribute `:iter` would have a more interesting result. Take a look at the code below:

    x = repeat (5):iter {|i|
         i * 2
    }

In this case, repeating process is not executed when the `repeat` function is evaluated.
`x` is an *iterator* that generates values of 0, 2, 4, 6 and 8,
and these values are only available when the iterator is actually evaluated.

The following code shows how to get the value after evaluating the iterator using Implicit Mapping:

    println(x)

Following code evaluates `x` step by step to confirm that it actually works as an iterator.

    println(x.next())
    println(x.next())
    println(x.next())
    println(x.next())
    println(x.next())

And now, to a next topic about iterators generated by repeating functions.

Consider the following code.

    f() = {
        n = 0
        while (n < 5):iter {
            n += 1
            n
        }
    }
    x = f()

The function `f` returns an iterator created by `while`,
which is expected to generate values of 1, 2, 3, 4 and 5.
In this case, the repeat body has a reference to a variable named `n` that belongs
to the scope of function `f`.
Can an iterator refer to a variable that may be destroyed at the end of a function?

Actually, it's OK. An iterator created by a repeating function owns an environment
in which the function has been called.
In the above example, the variable `n` is owned by the returned iterator.

You'll see more practical usage of this feature in [this](../articles/Script-to-Generate-Prime-Numbers.html).


topic about nesting:

    iterator#repeater()


## {{ page.chapter }}.3. Exception

    try - catch
    
    try():leader {block}
    catch(errors*:error):leader:trailer {block}
    
    raise(error:error, msg:string => 'error', value?)


