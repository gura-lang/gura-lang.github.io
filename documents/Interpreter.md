---
layout: page
lang: en
title: Interpreter
chapter: 6
---

# {{ page.chapter }}. {{ page.title }}

## {{ page.chapter }}.1. How Interpreter Works

The Interpreter looks up and modifies content of Environment
in accordance with Expressions that has been generated by parsing source codes.

The execution of the Interpreter consists of two stages **evaluation** and **assignment**.
In an evaluation stage, it looks up variables in Environment and do evaluation
depending on the current expression.
In an assingment stage, the Interpreter will add new variables
or modify existing variables in Environment.

In the Interpreter, Evaluation stage always occurs on each Expression
while Assignment stage only does when `Assign` expression is executed.

          +---------------+
          |  Expressions  |
          +---------------+
                  | control
                  V
    +----------------------------+     look-up     +---------------+
    |              evaluation <--|-----------------|               |
    |  Interpreter      |        |   assignment    |  Environment  |
    |                   `--------|---------------->|               |
    +----------------------------+                 +---------------+


## {{ page.chapter }}.2. Evaluation Stage

This section explains how each Expression acts in the Interpreter's evaulation stage.

* Evaluation result of a `Value` expression will be the value it owns in itself.

* An `Identifier` expression will look up a variable whose name matches the expression's symbol
  in an Environment and return the result value.
  If no variable is found, it occurs an error.

* A `Suffixed` expression will look up an entry in Suffix Manager
  that matches its suffix symbol and execute the entry with its body string.

* A `UnaryOp` expression evaluates the child expression it owns,
  and then evaluate the value with its associated unary operator.

* A `Quote` expression

* A `BinaryOp` expression evaluates both of the two child expressions it owns,
  and then evaluate the value with its associated Binary Operator.
  
  Binary Operator `&&` and `||` are exceptional.
  
  With operator `&&`, it first evaluates the child expression on the left.
  If the value is determined as **false**, that value is the result.
  Otherwise, it then evaluates the child expression on the right and returns the result.

  With operator `||`, it first evaluates the child expression on the left.
  If the value is determined as **true**, that value is the result.
  Otherwise, it then evaluates the child expression on the right and returns the result.

* Execution of an `Assign` expression triggers Assignment Stage. See the next section.

* A `Member` expression

  Class, Module and Object

* A `Lister` expression

        [1, 2, 3]

* An `Iterer` expression

        (1, 2, 3)

* A `Block` expression



* A `Root` expression

* An `Indexer` expression

        x[2]
        
        x[1, 2, 3]
        
        x['foo']

* A `Caller` expression evaluates expressions listed as its arguments.

        f(x)

        f(a, b, c, d)

        f(a, b):foo:bar

        f {}

  If the argument is declared as Quoted, it doesn't evaluates its argument.

## {{ page.chapter }}.3. Assignment Stage

Operation `x = y` assigns the value of `y` to `x`.

The expression of `x` may be one of `Identifer`, `Lister`, `Member`, `Indexer` and `Caller`.

* An assignment for an `Identifier` expression

        a = 3

  If a type name is specified as the `Identifier`'s  attribute,
  the source value will be casted to the type before assignment.

        a:number = '3'

* When the assignment destionation is a `Lister` expression,
  assignment operation is applied to each expression described as its element.
  Elements in the `Lister` must be `Identifier` expressions.
  
  If assignment source is a scholar, that value is assigned to each element.

        [a, b, c] = 3          // a = 3, b = 3, c = 3

  If assignment source is a list, each value in the list is assigned to each element.

        [a, b, c] = [1, 2, 3]  // a = 1, b = 2, c = 3

  It would be the same with an iterator.

        [a, b, c] = (1, 2, 3)  // a = 1, b = 2, c = 3

  If the assignment source has more elements than the destination requires,
  remaining elements are simply ignored.
  If the source has insufficient number of elements, it would occur an error.

        [a, b, c] = [1, 2, 3, 4, 5]  // a = 1, b = 2, c = 3
        [a, b, c] = [1, 2]           // error!

* A `Member` expression

  Class, Module and Object

        obj.var1 = 3
        obj.f(x) = { }

* An `Indexer` expression

        x[n] = 3
        
        x[0, 2, 5] = 3

        x[0, 2, 5] = [1, 2, 3]
        

* A `Caller` expression

        f(x) = x
        
        f(x) = { }

Assignments for other expressions than what are described above are invalid and occurs an error.


### {{ page.chapter }}.3.6. Operator before Assignment

An Assignment operator can be combined with one of several other operators.

<table>
<tr><th>Assignment Form</th><th>Equivalent Code</th></tr>
<tr><td><code>x += y</code></td><td><code>x = x + y</code></td></tr>
<tr><td><code>x -= y</code></td><td><code>x = x - y</code></td></tr>
<tr><td><code>x *= y</code></td><td><code>x = x * y</code></td></tr>
<tr><td><code>x /= y</code></td><td><code>x = x / y</code></td></tr>
<tr><td><code>x %= y</code></td><td><code>x = x % y</code></td></tr>
<tr><td><code>x **= y</code></td><td><code>x = x ** y</code></td></tr>
<tr><td><code>x &= y</code></td><td><code>x = x & y</code></td></tr>
<tr><td><code>x |= y</code></td><td><code>x = x | y</code></td></tr>
<tr><td><code>x ^= y</code></td><td><code>x = x ^ y</code></td></tr>
<tr><td><code>x <<= y</code></td><td><code>x = x << y</code></td></tr>
<tr><td><code>x >>= y</code></td><td><code>x = x >> y</code></td></tr>
</table>
